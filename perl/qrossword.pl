#!/opt/local/bin/perl
use strict;
use Text::QRCode;
use CGI;
use JSON;

# GLOBAL CONFIG
my $cdir = "/Users/patrick/qrossword/perl/cword";

# COLLECT ARGS
my $q = CGI->new;
my $level  = $q->param('level');
my $url    = $q->param('url'  );
my $size   = $q->param('size' );
my $action = $q->param('getqr' )||"";

if ($level !~ /^[LMH]$/)           { err("Incorrect level. Either LMH"); }
if ($url   !~ /^http\:\/\//)       { err("URL must start with http://"); }

####
# action eq generate_crossword
# get the base qr with *'s
my $arrayref = Text::QRCode->new( 'level' => $level )->plot($url);

####
# generate the crossword
# replace * with # first
&substitute_characters($arrayref,'*','#');
my $qrossword = generate_words_with_cword($arrayref);

####
# take the crossword generated by cwrod and sub ?'s for .'s.
&substitute_characters($qrossword,'?','.');

####
# remove small words 
# first horizontally
&check_closed_runs($arrayref);
# now vertically (flip it, do it, then flip it again)
my $transref = &transpose($arrayref);
&check_closed_runs($transref);
my $final = &transpose($transref);

####
# Take the original from qrossword and merge it with the one which has check_closed_runs done
my ($words_grays,undef) = &merge($qrossword,$final);

# dump the final grid
my $text_dump = &qr_text_dump($words_grays);


####
# Get the final results
my %grid;
my %words;
my $grid_counter=0;

get_final_results($words_grays,"a", \%grid, \%words);

my $words_grays_trans = &transpose($words_grays);

get_final_results($words_grays_trans,"d", \%grid, \%words);


######
# Dump the final results

# Assemble into a single hash
my %results;
#$results{'grid'} = \%grid;
$results{'words'} = \%words;
$text_dump =~ s/\n/\$/g;
$results{'raw'} = $text_dump;
$results{'url'} = $url;
$results{'level'} = $level;
$results{'date'} = time;
$results{'blocks'} = $#{$arrayref->[0]}+1;


my $json_txt = json_dump(\%results,1);

#print $q->header('application/json');
print $json_txt . "\n";

#END



#############################################################################################
# dump all results as a json object
sub json_dump {
	my ($hash,$pretty) = @_;

	# Dump as a single hash
	my $json = JSON->new;
	$json->pretty if $pretty;
	my $json_txt =  $json->encode( $hash);

	return $json_txt;
}


# notice this sub only runs horizontally through the matrix.
# if you need it vertically, then transpose the matrix and 
# pass anything other than "across" as the direction.
sub get_final_results {
	my($arrayref,$direction,$grid_hr,$words_hr) = @_;
	
	my $cols = $#{$arrayref->[0]}+1;
	my $rows = $#{$arrayref}+1;
	
	my $grid_counter = 0;
	for (my $y = 0 ; $y < $rows; $y++) {
		
		# for each row we want to track last cell blocked status
		# and word runs and word run starting gridref
		my $last_cell_blocked = 1;
		my $word = "";
		my $word_start_pt="";
		
		for (my $x = 0 ; $x < $cols; $x++) {
			
			# if the matrix has been transposed, then transpose x,y too so that grid refs pts are sane.
			my $pt = ($direction eq "a") ?"$x,$y":"$y,$x";
			
			# get cell details
			my $c = $arrayref->[$y][$x];
			my $cell_blocked = is_blocked($c);
			
			# Store the char
			if (! $cell_blocked ) {
				# maybe we don't need to store the original chars?
				$$grid_hr{$pt}{"c"} = $c;
				$word.=$c;
			}

			# Store the gray
			if ($c eq "." ) {
				$$grid_hr{$pt}{"g"} = 1;
			}

			# Mark a new word
			if ($last_cell_blocked && ! $cell_blocked) {
				# This is a new word
				$word = $c;
				$word_start_pt = $pt;
			}
			
			# Mark end of word. If we're in a word 
			# and we've just crossed a boundary or hit the end of the row, 
			# then save the word
			if ($word && ($cell_blocked || $x == $cols-1)) {
				
				# ignore vertical words with no width
				if (length($word) > 1 ) {
					my $grid_ref = &_get_grid_ref($grid_hr,$word_start_pt);
					$$words_hr{$grid_ref.$direction}{'w'} = $word;		
					$$words_hr{$grid_ref.$direction}{"l"} = length($word);	
					$$words_hr{$grid_ref.$direction}{"c"} = "";		
					$$words_hr{$grid_ref.$direction}{"g"} = $word_start_pt;		
					$$grid_hr{$word_start_pt}{"num"}  = $grid_ref;
				}

				# clear the word
				$word = "";
			}
			
			$last_cell_blocked = $cell_blocked;
		}
	}
}

# helper for get_final_results to lookup new or existing grid ref
sub _get_grid_ref {
	my ($grid_hr, $pt) = @_;

	my $grid_ref;
	if ( defined $$grid_hr{$pt}{"num"} ) {
		$grid_ref = $$grid_hr{$pt}{"num"};
		
	} else {
		$grid_counter++;			
		$grid_ref = $grid_counter;
	}
	
	return $grid_ref;
	
}


######################################################################

# sub * with #
sub substitute_characters {
	my ($arrayref,$orig_char,$new_char)= @_;
	
	my $cols = $#{$arrayref->[0]}+1;
	my $rows = $#{$arrayref}+1;
	
	die unless length($orig_char) == 1;
	die unless length($new_char) == 1;
	
	for (my $y = 0 ; $y < $rows; $y++) {
		for (my $x = 0 ; $x < $cols; $x++) {
			$arrayref->[$y][$x] =~ s/\Q$orig_char/$new_char/g;
		}
	}
}

# transpose cells. 2,4 goes to 4,2
sub transpose {
	my ($arrayref)= @_;
	my $transref;
	
	my $cols = $#{$arrayref->[0]}+1;
	my $rows = $#{$arrayref}+1;
	
	for (my $y = 0 ; $y < $rows; $y++) {
		for (my $x = 0 ; $x < $cols; $x++) {
			$transref->[$x][$y] = $arrayref->[$y][$x];
		}
	}
	
	return $transref;
}


sub merge {
	my ($arrayref,$arr2) = @_;
	
	my $cols = $#{$arrayref->[0]}+1;
	my $rows = $#{$arrayref}+1;
	
	my $arr3;
		
	for (my $y = 0 ; $y < $rows; $y++) {
		for (my $x = 0 ; $x < $cols; $x++) {
			my $v1 = $arrayref->[$y][$x];
			my $v2 = $arr2->[$y][$x];
			my $v3;
			if    ( $v1 =~ /\w/ ) {$v3 = $v1;}
			elsif ( $v2 =~ /\w/ ) {$v3 = $v2;}
			elsif ( $v1 =~ /\./ ) {$v3 = $v1;}
			elsif ( $v2 =~ /\./ ) {$v3 = $v2;}
			elsif ( $v1 =~ /\?/ ) {$v3 = ".";}
			elsif ( $v2 =~ /\?/ ) {$v3 = ".";} 
			elsif ( $v1 =~ /\#/ ) {$v3 = "#";}
			elsif ( $v2 =~ /\#/ ) {$v3 = "#";}
			else                  {$v3 = $v1;}
			$arr3->[$y][$x] = $v3;
			
		}
	}
	
	return ($arr3);
}


sub qr_text_dump {
	my ($arrayref)= @_;
	my $printed_grid="";
	
	my $cols = $#{$arrayref->[0]}+1;
	my $rows = $#{$arrayref}+1;
	
	for (my $y = 0 ; $y < $rows; $y++) {
		for (my $x = 0 ; $x < $cols; $x++) {
			$printed_grid.= $arrayref->[$y][$x] . "";
		}
		$printed_grid.= "\n";
	}
	return $printed_grid;
}

sub check_closed_runs {
	my ($arrayref)= @_;
	
	my $cols = $#{$arrayref->[0]}+1;
	my $rows = $#{$arrayref}+1;
	
	for (my $y = 0 ; $y < $rows; $y++) {
		for (my $x = 0 ; $x < $cols; $x++) {

			if (is_blocked($arrayref->[$y][$x-1])) {
				check_next_cell_is_blocked($arrayref,$x,$y);				
			}

		}
	}
}

# returns 2 if it is blocked
# returns 1 if it is clear but blocked_above_and_below
# returns 0 if it is clear or it is clear above and below
sub check_next_cell_is_blocked {
	my ($a,$x,$y) = @_;
	my $cell = $a->[$y][$x];
	
	my $cols = $#{$a->[0]}+1;
	my $rows = $#{$a}+1;
	
	if ($x >= $cols || $y >= $rows || is_blocked($cell) ) {
		return 2;
	}
	
	if ( blocked_above_and_below($a,$x,$y) ) {
		set_cell($a,$x,$y,".");
		
		my $is_next_cell_blocked = &check_next_cell_is_blocked($a,$x+1,$y);
		if ( $is_next_cell_blocked == 0) { # next is clear, so clear it out
			set_cell($a,$x,$y," ");
			return 0;
		}
		
		return 1;
	}
	else
	{
		return 0;		
	}
}


sub is_blocked {
	($_[0] eq "#" || $_[0] eq "." ) ? 1 : 0;
}

sub set_cell {
	my ($a,$x,$y,$val) = @_;
	$a->[$y][$x]=$val;
}


sub blocked_above_and_below {
	my ($arr,$x,$y) = @_;
	(
		_blocked_above($arr,$x,$y) &&
		_blocked_below($arr,$x,$y) 
	) ? 1:0;
}

sub _blocked_above {
	my ($arr,$x,$y) = @_;
	#my $cell = $arr->[$y-1][$x];
	#print "$x,$y: $cell\n";
	return ( $y<=0 || is_blocked($arr->[$y-1][$x]) ) ? 1:0;
}

sub _blocked_below {
	my ($arr,$x,$y) = @_;
	my $rows = $#{$arr};
	return ( $y>=$rows || is_blocked($arr->[$y+1][$x]) ) ? 1:0;
}

sub generate_words_with_cword {
	my ($array) = @_;
	
	my $tmp_file = _save_array_to_tmp_file($array);
	

	chdir($cdir);
	my $command = "$cdir/cword $tmp_file $cdir/ANC-spoken-count-cleaned.txt";
	open(C,"$command|") || msg("Couldn't call $command");
	
	my $qrossword;
	while(<C>){
		next if /^fo/;
		$qrossword .= $_;
	}
	
	unlink $tmp_file;
	
	my $qrossword_arrayref = txt_to_arr($qrossword);

	return $qrossword_arrayref;	
}

sub _save_array_to_tmp_file {
	my ($str) =@_;
	
	my $tmp_file = "/tmp/qr_$$.txt";
	open (F,">$tmp_file") || msg ("Couldn't write to $tmp_file");
	my $array_txt = qr_text_dump($str);
	print F $array_txt;
	close F;
	
	return $tmp_file;
}

sub txt_to_arr {
	my($txt) = @_;

	my $y=0;
	my $arr;
	my @rows = split('\n',$txt);
	
	foreach(@rows) {
		chomp;
		my @arr = split('');
		$arr->[$y++] = \@arr;

	}

	return $arr;
}


#####
sub err {
	my ($msg) = @_;
	print $q->header . $msg ."\n"; 
	exit;
}
